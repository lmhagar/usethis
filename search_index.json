[["index.html", "Topics in Statistical Consulting Preface Authors Editors", " Topics in Statistical Consulting Statistical Consulting and Collaborative Research Unit University of Waterloo 2022-11-11 Preface This book aims to give introductions to some topics in statistical consulting. We hope that this will help audiences who have light background in statistics. For contributors to this book, please refer to the Appendix for General Guidelines, Formatting Guidelines and Github tutorials. For questions regarding the materials of this book, please contact us. Authors Trang Bui Meixi Chen Luke Hagar Kelly Ramsay Yuliang Shi Grace Tompkins Feiyu Zhu Editors Martin Lysy Glen McGee Joslin Goh "],["introduction-to-r.html", "1 Introduction to R 1.1 R and RStudio 1.2 Basic R 1.3 Basic Data Analysis Workflow 1.4 Some Coding Tips 1.5 Getting Help", " 1 Introduction to R Author: Joslin Goh, Trang Bui Last Updated: Feb 04, 2021 1.1 R and RStudio R is a software environment for statistical computing and graphics. Unlike other statistical software, R is free. Besides built-in functions, additional packages for solving many different statistical or application problems are made and maintained by contributors around the world. This makes R an attractive and popular statistical tool nowadays. RStudio is an integrated development environment (IDE) for R. It is easier to work with R using RStudio. Figure 1.1: The RStudio interface The interface of RStudio shown in Figure 1.1 contains four panes: Source Editor, Console, Workspace Browser, and Files (and Plots, Packages, Help, and Viewer). The four panes can be positioned differently based on personal preference. Figure 1.1 shows the default position. In this section, we will mainly be using the Source Editor and Console panes. Readers are encouraged to refer to other resources on the use of other panes. 1.2 Basic R 1.2.1 Calculating with R In its simplest form, R can be used as a calculator. In the R Console area, type: 1 + 2 The following will be printed in the R Console area: [1] 3 Subtraction can be done in a similar way: 5 - 10 [1] -5 Other basic operations such as multiplication, division, and powers are also included. 9 * 26 [1] 234 100 / 7.5 [1] 13.33333 2^3 [1] 8 Some basic operations involve built-in functions in R. For example, Square root: sqrt(25) [1] 5 Logarithm: log(10, base = 10) [1] 1 Natural logarithm: log(10) [1] 2.302585 1.2.2 Variables Variables are useful when they need to be used repeatedly or to be recalled in the future. For example, suppose we are interested in evaluating \\[ \\frac{e^{1-9.2315468}}{1-e^{1-9.2315468}}, \\] we can store the repeated value \\(9.2315468\\) as a variable before performing the calculation. To store the value as the variable \\(x\\), we can type x &lt;- 9.2315468 Note that: In the Console pane, nothing is returned. In the Environment tab under the Workspace Browser pane, \\(x\\) appears together with the value it represents. This shows that the current workspace recognizes \\(x\\) as \\(9.2315468\\). Now if we try typing \\(x\\) in the Console, we will see the value it represents. x [1] 9.231547 Back to our example, we wanted to evaluate \\[ \\frac{e^{1-9.2315468}}{1-e^{1-9.2315468}}, \\] Since \\(x = 9.2315468\\) is in our work environment, we can now type exp(1 - x) / (1 - exp(1 - x)) [1] 0.0002661952 In R, there are built-in variables, which are called default variables in R. The number \\(\\pi\\) is recognized as pi. Another default variable is the imaginary number, i.e \\(\\sqrt{-1}\\), which is recorded as i in R. 1.2.3 Vectors Oftentimes, we encounter sequences of numbers during data analysis. For example, the height of 10 students, the grades of the ECON 101 students in the Fall term, the age of the attendees, etc. In R, sequences of numbers can be recorded as vectors. Suppose there are five people in a class. The ages of the people in the class are: \\[ 18, 21, 19, 20, 21 \\] We can create a vector for our record as below. age &lt;- c(18, 21, 19, 20, 21) In the Workspace Browser pane, we can see the variable age with the values that we have given. And if we type age in the Console pane, we get these values printed in the Console. Vectors may not appear to be useful for many since most of the popular functions are ready for use. But for those intending to create their own R functions, it is important to understand how to create and manipulate vectors. Many comparators and logical operators such as those discussed in Section 1.2.1 work on both vectors and scalars. These calculations will be element-wise. 1.3 Basic Data Analysis Workflow 1.3.1 Reading Data into R 1.3.1.1 Setting Working Directory To start, it is important to inform R the directory that the data file is stored. For Mac/Windows users of RStudio, choose Session &gt; Set Working Directory &gt; Choose Directory. The function setwd() can also be used to set the working directory if the directory string is available. For example, setwd(&quot;D:/&quot;) will set the working directory to “D:/”. 1.3.1.2 Importing the Data In the real world, data are recorded in different formats such as Excel spreadsheet (xls), Comma Separated Values (csv) or Text (txt). Each row of a data file is an observation while each column is a variable or a feature. Data are imported into the R Environment using functions such as read.csv() and read.table(). Imported data are stored as a data frame object. In this section, we will look at two data sets: caliRain.csv and drinks.csv. Suppose we saved the data sets in a subfolder called data in the working directory. We can import both data sets caliRain.csv and drinks.csv into the R environment and save them as data frames called drinks_df and rain_df respectively. drinks_df &lt;- read.csv(&quot;data/drinks.csv&quot;) rain_df &lt;- read.csv(&quot;data/caliRain.csv&quot;) 1.3.1.3 A Look at the Data It is important to take a look at the data set imported into the environment before performing the analysis. To view rain_df as a table, View(rain_df) The function head() can also show the first few rows of the data set. head(rain_df) STATION PRECIP ALTITUDE LATITUDE DISTANCE SHADOW 1 Eureka 39.57 43 40.8 1 1 2 RedBluff 23.27 341 40.2 97 2 3 Thermal 18.20 4152 33.8 70 2 4 FortBragg 37.48 74 39.4 1 1 5 SodaSprings 49.26 6752 39.3 150 1 6 SanFrancisco 21.82 52 37.8 5 1 The caliRain.csv file contains daily rainfall recorded at numerous meteorological stations monitored by the state of California. The variables recorded are: STATION: Name of the station, PRECIP: precipitation (inches), ALTITUDE: altitude (feet), LATITUDE: latitude (feet), DISTANCE: distance to the Pacific Ocean (miles), and SHADOW: slope face (1: Westward, 2:Leeward). The variables STATION and SHADOW are categorical variables, whereas the remaining are continuous variables. 1.3.1.4 Accessing the Data Frame Oftentimes, we are interested in accessing an individual column (or variable) within the data frame. For example, if we are interested in the PRECIP variable in the data set caliRain.csv (which is now stored as rain_df). There are two ways to access the column: Use the dollar sign followed by the name of the variable. rain_df$PRECIP [1] 39.57 23.27 18.20 37.48 49.26 21.82 18.07 14.17 42.63 13.85 9.44 19.33 [13] 15.67 6.00 5.73 47.82 17.95 18.20 10.03 4.63 14.74 15.02 12.36 8.26 [25] 4.05 9.94 4.25 1.66 74.87 15.95 Use the number of the column in the data set. rain_df[, 2] [1] 39.57 23.27 18.20 37.48 49.26 21.82 18.07 14.17 42.63 13.85 9.44 19.33 [13] 15.67 6.00 5.73 47.82 17.95 18.20 10.03 4.63 14.74 15.02 12.36 8.26 [25] 4.05 9.94 4.25 1.66 74.87 15.95 Similarly, there are times we want to investigate a particular row (or observation). Suppose we are interested in the 10th observation, type rain_df[10, ] STATION PRECIP ALTITUDE LATITUDE DISTANCE SHADOW 10 Salinas 13.85 74 36.7 12 2 We can also access a specific cell in the data. If we want to access the precipitation of the 5th observation, we can do either one of the following: rain_df$PRECIP[5] rain_df[5, 2] Accessing a random variable, an observation or a specific value coming from an observation are all useful for data management and manipulation purpose. 1.3.1.5 Modifying the Data Frame Sometimes, we want to make changes to the data frame such as making changes to existing records, adding new observations or variables, or removing outliers from the data set. If we want to change the existing records, we need to identify which records we are interested to change. a variable, i.e. a column, or a specific observation. 1.3.1.5.1 Modifying a Variable To modify a variable, we need to identify the name or the column of the variable to access it in the data frame, decide on the modification or conversion, and decide on how to store the new variable. We recommend storing the conversion as a new variable in the data frame to avoid confusion. Suppose we are interested to analyze DISTANCE in meters (\\(1 \\tx{ ft} = 0.3048 \\tx{ m}\\)). We can make the conversion and save it as a new column called DISTANCE_M in the data set. rain_df$DISTANCE_M &lt;- rain_df$DISTANCE * 0.3048 1.3.1.5.2 Modifying a Specific Observation To modify a specific observation, we need to identify how to access the variable in the data frame, decide on the modification, and decide on how to store the new variable. Suppose the distance for Eureka station is entered incorrectly and is supposed to be 1.5 feet instead. To replace this value, type rain_df$DISTANCE[1] &lt;- 1.5 1.3.1.5.3 Removing Records To remove an entire column from a data frame, rain_df &lt;- rain_df[, -COLUMN_NUMBER] To remove an entire row from a data frame, rain_df &lt;- rain_df[-ROW_NUMBER, ] This way we re-store rain_df with the new data frame rain_df where its row/column has been removed. 1.3.1.6 Data Structure The structure that R stores the data can be viewed using the function str(). str(rain_df) &#39;data.frame&#39;: 30 obs. of 7 variables: $ STATION : chr &quot;Eureka &quot; &quot;RedBluff &quot; &quot;Thermal &quot; &quot;FortBragg &quot; ... $ PRECIP : num 39.6 23.3 18.2 37.5 49.3 ... $ ALTITUDE : int 43 341 4152 74 6752 52 25 95 6360 74 ... $ LATITUDE : num 40.8 40.2 33.8 39.4 39.3 37.8 38.5 37.4 36.6 36.7 ... $ DISTANCE : num 1.5 97 70 1 150 5 80 28 145 12 ... $ SHADOW : int 1 2 2 1 1 1 2 2 1 2 ... $ DISTANCE_M: num 0.305 29.566 21.336 0.305 45.72 ... Here, the variable SHADOW is recorded as a numeric value. This is not an accurate depiction of the data set. To ensure the analysis can be done properly, we need to convert the values in SHADOW into categorical values in the data set. To do so, we use the function factor(). rain_df$SHADOW &lt;- factor(rain_df$SHADOW, levels = c(&quot;1&quot;, &quot;2&quot;), labels = c(&quot;Westward&quot;, &quot;Leeward&quot;) ) Here, the numerical values 1 and 2 are set to “Westward” and “Leeward”, respectively. Now, when we check the structure of the data set after the transformation, the variable SHADOW is now stored as a categorical variable (or factor). str(rain_df) &#39;data.frame&#39;: 30 obs. of 7 variables: $ STATION : chr &quot;Eureka &quot; &quot;RedBluff &quot; &quot;Thermal &quot; &quot;FortBragg &quot; ... $ PRECIP : num 39.6 23.3 18.2 37.5 49.3 ... $ ALTITUDE : int 43 341 4152 74 6752 52 25 95 6360 74 ... $ LATITUDE : num 40.8 40.2 33.8 39.4 39.3 37.8 38.5 37.4 36.6 36.7 ... $ DISTANCE : num 1.5 97 70 1 150 5 80 28 145 12 ... $ SHADOW : Factor w/ 2 levels &quot;Westward&quot;,&quot;Leeward&quot;: 1 2 2 1 1 1 2 2 1 2 ... $ DISTANCE_M: num 0.305 29.566 21.336 0.305 45.72 ... 1.3.2 Descriptive Statistics We will use the PRECIP variable to demonstrate how common statistics are computed. Mean or average of a sequence of numbers can be obtained using the function mean(). mean(rain_df$PRECIP) [1] 19.80733 Median of a sequence of numbers can be obtained using the function median(). median(rain_df$PRECIP) [1] 15.345 Variance and standard deviation of a sequence of numbers can be obtained using the functions var() and sd() respectively. var(rain_df$PRECIP) [1] 276.2639 sd(rain_df$PRECIP) [1] 16.62119 The minimum and maximum of a set of numbers can be obtained through functions min() and max(). min(rain_df$PRECIP) [1] 1.66 max(rain_df$PRECIP) [1] 74.87 The function range() also shows the minimum and maximum values. range(rain_df$PRECIP) [1] 1.66 74.87 1.3.3 Data Visualization There is a wide variety of plots that can be created using R, but we will focus on some of our favorites: bar graphs: show the distributions of categorical variables, boxplots: show the five-number summaries of continuous variables, and histograms: show the distributions of continuous variables. 1.3.3.1 Categorical Variables In order to create bar graphs, we need to summarize data using tables. The numerical summary of a categorical variable are usually summarized in a table: count_of_shadow &lt;- table(rain_df$SHADOW) count_of_shadow Westward Leeward 13 17 A cross-tabulation table (or contingency table) can also be done. Suppose we are interested to create cross-tab for the variables hasMilk and temp in the drinks_df, we can do the following: table_of_milk_by_temp &lt;- table( drinks_df$hasMilk, drinks_df$temp ) table_of_milk_by_temp Cold Hot Milk 20 10 Nonmilk 6 0 Sometimes it is more useful to report the proportions, which can be converted into percentages. To do so, we use the function prop.table(). prop.table(count_of_shadow) Westward Leeward 0.4333333 0.5666667 For a contingency table, the default prop.table() function will output the proportions based on the entire data set. prop.table(table_of_milk_by_temp) Cold Hot Milk 0.5555556 0.2777778 Nonmilk 0.1666667 0.0000000 Suppose we are interested in the percentages of the hot drinks that contain milk, we will want to report the proportion by column (Temperature). prop.table(table_of_milk_by_temp, 2) Cold Hot Milk 0.7692308 1.0000000 Nonmilk 0.2307692 0.0000000 These values are the proportions of drinks which contains milk (or not) conditioning on whether the drink is cold or hot, i.e., the values are normalized by the columns. 1.3.3.2 Bar Graphs Bar graphs are commonly used to visualize categorical variables. We can make a bar graph from the count table using the function barplot() in R. barplot(count_of_shadow, main = &quot;Distribution of shadow&quot;, xlab = &quot;Shadow&quot;, ylab = &quot;Frequency&quot; ) 1.3.3.3 Boxplots The boxplot is a visual representation of the five-number summary that can give us a sense of the distribution of the variable. minimum, first quartile, \\(Q_1\\), second quartile, i.e., median, third quartile, \\(Q_3\\), and maximum. Potential outliers are shown as dots outside the boxplots. The boxplot of PRECIP shows some potential outliers. boxplot(rain_df$PRECIP, main = &quot;Precipitation&quot;, ylab = &quot;Inches&quot; ) Side-by-side boxplots are commonly used to visualize the relationship between a continuous variable and a categorical variable. The following is the boxplot of the precipitation by shadow. boxplot(rain_df$PRECIP ~ rain_df$SHADOW, main = &quot;Precipitation&quot;, ylab = &quot;Inches&quot; ) In the side-by-side boxplots, notice that there are no potential outliers. Compared to the whole data, certain observations can be considered as outliers. But if we group the data by SHADOW, the data are not outliers in their groups. 1.3.3.4 Histograms Histograms are commonly used to visualize the distribution of continuous variables. When looking at histograms, pay attention to the shape: symmetric vs asymmetric, the center, and the spread. To plot precipitation in a histogram, hist(rain_df$PRECIP, main = &quot;Distribution of precipitation&quot;, xlab = &quot;Precipitation&quot;, ylab = &quot;Inches&quot; ) Notice that there is no space in between the bars like in the bar graph. This is because the graph is for continuous variables instead of categorical variables. 1.3.3.5 Scatterplots Scatterplots are used to visualize the relationship between two continuous variables. plot(rain_df$DISTANCE, rain_df$PRECIP, main = &quot;Relationship: precipitation vs distance&quot;, xlab = &quot;Distance (ft)&quot;, ylab = &quot;Precipitation (inches)&quot; ) 1.3.3.6 A Fancy Visualization Library The ggplot2 library is a package created by Hadley Wickham. It offers a powerful language to create elegant graphs. A basic introduction of this package can be found in a later section. 1.4 Some Coding Tips 1.4.1 Source Editor It will be hard to remember and troublesome to re-write all the codes created in the Console every time, especially if there are many lines of code. The Source Editor allows us to write and save all codes into R code files. The lines of codes in the Source Editor are not processed by R unless executed by the user. There are many ways the codes in the Code Editor can be executed: Select the codes to process, click Run on the top right corner of the Source Editor. For Windows users, run the selected codes by pressing Ctrl + Enter. For Mac users, use Command + Enter. If we only want to run one line of code, place the cursor at the line of code, and use either one of the two ways mentioned above. We recommend typing the codes in the Source Editor and then executing the codes. This way, there is a copy of what was done for future references. 1.4.2 Commenting Comment the codes! To do so, use #. R does not process anything behind #. For example, # I am trying to like R!!!! Everyone uses comments differently, but generally, comments are useful for understanding what is the code for and sometimes, the expected output. To comment off a block of code, select the lines, and press Ctrl + Shift + C. Doing this a second time, the code section will be uncommented. In RStudio, if the following is done in the Code Editor: # ---------------- # Try Me! # ---------------- a triangle button will appear next to the line numbers at the beginning and end of the code section. Clicking the button will hide or unhide the section. 1.4.3 Saving the Environment When quitting R or RStudio, we can choose to save the Environment and History that we were working with in the files called .RData and .RHistory respectively. When we open the R code file next time, the two files will be automatically loaded. However, it is recommended not to save the Environment in the default way. Instead, start in a clean environment so that older objects do not remain in the environment any longer than they need to. If that happens, it can lead to unexpected results. For those who want to save the Environment for future use, we recommend saving the Environment using the function save.image() rather than using the default files .RData. If we only want to save certain values, we can use the function save() and then load the saved Environment later using the load() function. 1.4.4 Installing and Loading Libraries The R user community creates functions and data sets to share. They are called packages or libraries. The packages are free and can be installed as long as there is access to the Internet. To install a library, say ggplot2, you can either use the RStudio interface, or you can do it from the command line as follows: install.packages(&quot;ggplot2&quot;, dependencies=TRUE) You only need to do this once in a while, e.g., when you install a new version of R. Then, to use the package, include the following code at the beginning of the file: require(ggplot2) Loading required package: ggplot2 This command needs to be run every time you want to use the package in a new R session. 1.4.5 Good Coding Practices Start each program with a description of what it does. Load all required packages at the beginning. Consider the choice of working directory. Use comments to mark off sections of code. Put function definitions at the top of the file, or in a separate file if there are many. Name and style code consistently. Break code into small, discrete pieces. Factor out common operations rather than repeating them. Keep all of the source files for a project in one directory and use relative paths to access them. Have someone else review the code. Use version control. 1.5 Getting Help Before asking others for help, it is generally a good idea for you to try to help yourself. 1.5.1 R Documentation R has extensive documentation and resources for help. To read the documentation of a function, add a question mark before the name of a function. For example, to find out how to use the function round(), try ?round The description of the function and examples of how to use it will appear in the Files pane. In this example, as shown in the documentation, the function round() rounds the values in its first argument to the specified number of decimal places. 1.5.2 Online Resources There are a lot of basic functions or default variables that have not been mentioned so far. When analyzing data, we often encounter situations in which we need to use unknown or unfamiliar functions. In this case, we often rely on online search engines to find those functions. It is common practice to use online resources in real-world data analysis. Hence, readers are encouraged to explore the online resources. "],["introduction-to-ggplot2.html", "2 Introduction to ggplot2 2.1 Introduction 2.2 Data 2.3 Aesthetics 2.4 Geometrics 2.5 Others", " 2 Introduction to ggplot2 Author: Joslin Goh Last Updated: Feb 09, 2021 2.1 Introduction In this chapter, we assume that the readers have a basic understanding of R and RStudio. We have prepared a chapter for those who need a quick introduction to R and RStudio. ggplot2 is a data visualization package for R and RStudio. It is implemented based on Wilkinson (2012). The package can be installed and loaded using the command: require(&quot;ggplot2&quot;) The layers of a graph are shown in Figure 2.1. In this chapter, we will show you how to build a plot layer by layer. Figure 2.1: The layers of a graph 2.1.1 Example Data Set The examples shown in this chapter come from the data set diamond from the ggplot2 package. data(&quot;diamonds&quot;) The diamond data set consists of the price, quality information, and physical measurements of different diamonds. The structure of the data set is displayed using the function str(). str(diamonds) tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame) $ carat : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... $ depth : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... $ table : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... $ price : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... The diamond data set consists of many data points. To simplify the illustration, we will only use a subset of the data. To sample a subset: set.seed(2019) my.diamonds &lt;- diamonds[sample(nrow(diamonds), 100), ] The function set.seed() ensures that the sample is consistent and replicable. 2.2 Data The first step to graphing is to specify the data set and decide what goes on the axes. Suppose we want to investigate how the price of a diamond behaves with respect to its carat. Then, the two variables (or columns) involved are price and carat. The x-axis is usually the explanatory variable and the y-axis is the dependent variable. In this scenario, price should be on the y-axis and carat on the x-axis. To initiate this graph in ggplot2, ggplot(my.diamonds, aes(x = carat, y = price)) Figure 2.2: A blank canvas. The command creates a blank plot with no points or lines in it. The function does not assume the type of graphs it needs to produce unless it was told. Since this is the first (base) layer which will be used over and over again, it is best to save it as an object: p &lt;- ggplot(my.diamonds, aes(x = carat, y = price)) 2.3 Aesthetics The first layer to be added onto the blank plot is a layer of the data points. In our case, we are interested to make a scatterplot that involves points that represent the data on the graph. The function geom_point() adds the necessary points onto the base layer. p + geom_point() Figure 2.3: A scatterplot of the price of diamond vs diamond carat. Each layer has its own components. For this layer, the common components include: col: the colour of the points specified using names, rgb specification or NA for transparent colour, size: the size of the points specified in millimeters, and shape: the shape of the points. 2.3.1 The Colour Component A common way to specify the colour of the points is through the name of the colours. For example, red, darkblue, magenta, chocolate etc. A complete list of colours can be found here. Suppose we want the points to appear blue, we can change it by using the option col. p + geom_point(col = &quot;blue&quot;) Figure 2.4: The colour of the points is set to blue. When col=NA, the points will become transparent: p + geom_point(col = NA) Figure 2.5: The points on the scatterplot has become invisible. 2.3.1.1 Setting vs Mapping So far, we set the colour of the points to a specific colour of our choice. In some cases, we prefer the colour to change based on the information from another column (usually categorical) in the data set. For example, suppose we want the colour of the points on the graph to change based on cut, which has 5 categories: Fair, Good, Very Good, Premium and Ideal. p + geom_point(aes(col = cut)) Figure 2.6: Colouring the points based on the cut variable. This is called mapping. 2.3.1.2 Changing the Colour Palette The choice of colours used in aes() is determined by the choice of the colour palette. When the choice is not mentioned, the default option is used. There are many online packages with pre-set palettes that you can use. We will show you the most common one known as RColorBrewer, which includes three types of colour palettes: sequential, diverging and qualitative. require(RColorBrewer) Loading required package: RColorBrewer display.brewer.all() Figure 2.7: Palettes available in RColorBrewer. The first chunk shows palettes suitable for sequential categories, the middle chunk consists of palettes suitable for nominal categories whereas the last chunk of palettes are recommended for diverging categories. Suppose we want to use the BuGn colour palette from RColorBrewer on the scatterplot created earlier, we can use the function scale_colour_brewer(): p1 &lt;- p + geom_point(aes(col = cut)) p1 + scale_colour_brewer(palette = &quot;BuGn&quot;) Figure 2.8: The points are coloured with the BuGn colour palette which was recommended for sequential categories. Readers can refer here for more information about RColorBrewer. Our preference is to use a colour-blind friendly palette such as: Figure 2.9: Colour blind friendly palette (grey) Figure 2.10: Colour blind friendly palette (black) Both palettes are not part of RColorBrewer and are extracted from Cookbook for R. They are coded as follows: # colour blind friendly palette with grey cbgPalette &lt;- c( &quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot; ) # colour blind friendly palette with black cbbPalette &lt;- c( &quot;#000000&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot; ) Readers can also create palettes of their choice at Color Brewer 2.0. If you chose to create your own palette, we recommend having them included at the beginning of your R script. In order to use the colour blind friendly palettes that are not part of the RColorBrewer library, we need to use scale_colour_manual instead. p1 + scale_colour_manual(values = cbbPalette) Figure 2.11: Colouring the points with the colour-blind palette. The colour is determined by cut. 2.3.2 The Size Component Another component of geom_point() is the size of the points. They can be changed by either setting or mapping. The size of the points is specified in millimeters. 2.3.2.1 Setting the Size To change the size of all the points in the plot to 5mm, p1 + geom_point(size = 5) Figure 2.12: The points in the scatterplot is set to 5mm. The points are larger than the default size in the previous figures. The points in Figure 2.12 are larger, which is as we hoped for. However, the colours of the points are the same. This contradicts our previous effort on mapping the colours of the points to cut and saved it as p1 earlier. The reason is that geom_point() was called when we created p1, so when we called the geom_point() again to set the size, it overwrites the command to map the colours of the points. In order to change the colour and size at the same time, we need to do so within the same geom_point(). p + geom_point(aes(col = cut), size = 5) 2.3.2.2 Mapping the Size Similar to mapping the colour component, the sizes of the points can be mapped to a variable. p1 + geom_point(aes(size = cut)) Figure 2.13: Mapping the size of the points based on the cut variable. Notice in Figure @ref{fig:visgg-aes-size-map} that the points are black in colour but the legend still includes cut. This is because the mapping contradicts p1 that was stored in such a way earlier: p1 &lt;- p + geom_point(aes(col = cut)) The plot appears “incorrect” and there will be a lot of warnings, which is not printed here. In order to map both colour and size properly, we need to, again, specify the mapping of both colour and size at the same time. p + geom_point(aes(col = cut, size = cut)) Figure 2.14: Mapping the colour and size of the points to the cut variable. 2.3.3 The Shape Component Another component to consider is the shape of the points, which are identified using numbers. The default shape of points is circle. Figure 2.15: The shapes available in the package. Suppose we want to set the shapes of the points to inverted triangles without changing the size and colour of the points, we start with the p object and make changes through geom_point(). p + geom_point(shape = 6) Figure 2.16: Changing the points to inverted triangles To map the points to the cut of the diamonds and set the size of all the points to 5mm, p + geom_point(aes(shape = cut), size = 5) Figure 2.17: Mapping the shape and setting the size of the points at the same time. You may have received a warning that the shape component is not recommended for ordinal variables such as cut. This is a recommendation. Usually, the shape component is used to better visualize nominal variables. It is the readers’ choice to manipulate the shape component for better visual presentation. To summarize, we recommend including the choice of colour, size and shape in one call of geom_point() to minimize error. For example, p + geom_point(aes(col = cut, size = cut, shape = cut)) 2.4 Geometrics Geometric objects perform the actual rendering of the layer and control the type of plot that you created. The common ones are: geom_point() produces scatterplots, geom_line() produces line graphs, and geom_bar() produces bar plots. 2.4.1 Line Graphs Previously we have been drawing scatterplots to draw the relationship between carat and price. We used geom_point(). What happens if we used geom_line()? p + geom_line() Figure 2.18: A line graph to show relationship between diamond carat and price. 2.4.1.1 Setting Colour, the Thickness and Type of Line Similar to geom_point(), we can set the colour of the line to red. p + geom_line(col = &quot;red&quot;) Figure 2.19: Setting the colour of the line graph to red. The thickness of the line can also be changed. It is set to 1 by default, but we can change it to any decimal of our choice. The larger the number, the thicker the line. p + geom_line(size = 1.5) Figure 2.20: Setting the thickness of the line to 1.5mm The default type of line is a solid line, which is also coded as 1. There are a total of 12 types of lines, in which seven of them can also be referred to using numbers 0 to 6 instead of the string values. We can change the solid line into dashed as follow: p + geom_line(linetype = &quot;dashed&quot;) Figure 2.21: The solid line has changed to dashed line. 2.4.1.2 Multiple Lines To draw multiple lines, the points must be grouped by a variable. Otherwise, all the points will be connected by a single line. Hence, when we create the base layer, we need to specify the group that we want to group the points into. Usually, the grouping is based on a categorical variable. Suppose we are interested to draw the lines according to cut. p2 &lt;- ggplot(my.diamonds, aes(x = carat, y = price, group = cut)) p2 + geom_line() Figure 2.22: Multiple lines (based on cut) are drawn in the same figure. We can adjust the colour by the group. To map the colours of the lines to cut, there are two options: Option 1: ggplot(my.diamonds, aes(x = carat, y = price, group = cut)) + geom_line(aes(col = cut)) Option 2: ggplot(my.diamonds, aes( x = carat, y = price, group = cut, col = cut )) + geom_line() Both options produce the exact same graph. However, we prefer Option 2 over Option 1 because we can manipulate the components of the line (and points) more efficiently when creating graphs that are more complex later on. 2.4.1.3 Lines with Points It is no surprise that we can add points in a line graph: p + geom_line() + geom_point() The appearance of the lines and points can be changed as discussed previously. 2.4.2 Bar Plots Bar plots are commonly used to graph categorical variables. Suppose we are interested in how the total price of diamonds is affected by the different colour. After laying down the base layer with price on the y-axis and color on the x-axis, we use the geom_bar() function to create the bars in the graph. ggplot(my.diamonds, aes(x = color, y = price)) + geom_bar(stat = &quot;identity&quot;) Notice that the x- and y-axes are similar to that of the scatterplots. The only difference is the use of geom_bar(). The colours of the bar can be mapped to the color variable by specifying the fill option. ggplot(my.diamonds, aes(x = color, y = price, fill = color)) + geom_bar(stat = &quot;identity&quot;) 2.5 Others It may be of interest to change x- and y-axes labels, title of the graph, and legends. 2.5.1 Axes Labels Similar to graphing in the base package, we can change the labels of the axes by adding the components as follows: x-axis: xlab(\"name\") y-axis: ylab(\"name\") p + geom_line(col = &quot;red&quot;) + xlab(&quot;Price&quot;) + ylab(&quot;Carat&quot;) 2.5.2 Title of the Graph To add a title to the graph, we can use ggtitle(): p + geom_line(col = &quot;red&quot;) + xlab(&quot;Price&quot;) + ylab(&quot;Carat&quot;) + ggtitle(&quot;Relationship between price and carat&quot;) The title is left-centered and can be adjusted through the “theme” layer which we will not cover here. In general, we prefer to not add a title to the graph because captions would be added in the final presentation of the data and results. 2.5.3 Legends There are two ways for changing the title and labels of the legend: modify the data frame directly, or use scale_xxx_yyy(). Refer here for the different combinations of xxx and yyy. Suppose we want the legend to show the cut in different colours. Since the legend is related to the colour of the lines, xxx is colour and the variable is categorical, we set yyy to discrete: p + geom_line(aes(col = cut)) + scale_colour_discrete( name = &quot;Cut of diamonds&quot;, breaks = c(&quot;Fair&quot;, &quot;Good&quot;, &quot;Very Good&quot;, &quot;Premium&quot;, &quot;Ideal&quot;), labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) ) References "],["general-guidelines.html", "A General Guidelines A.1 Resources A.2 Format A.3 Rendering the Book", " A General Guidelines Author: Martin Lysy Last Updated: Nov 17, 2020 A.1 Resources R Markdown: The bookdown e-book the Definitive R Markdown Guide and the R Markdown Cookbook. LaTeX: Basic and advanced math formatting guides. Collaborations: The Pro Git book, and a quick tutorial here. A.2 Format bookdown is an R package which allows us to integrate scientific writing (including math, figures, etc.) with executable programming blocks. While bookdown is interfaced through R, very little R knowledge is required to operate it. The scientific writing is done in Markdown and LaTeX, whereas the programming blocks can be written in R, Python, Julia, C++, etc. In terms of content, please focus on the following: Creating a clear organization of topics within your module using section/subsection/subsubsection headers. Setting up the code, for example, in a clear and well-organized manner, i.e., what to include directly in the .Rmd file and what goes into external scripts, using lots of code comments, informative variable names, and consistent naming conventions, etc. In terms of formatting the content with R Markdown, please refer to the Formatting Guidelines. A.2.1 Typesetting Math Please do take a look at the LaTeX guides above, as it is easy to do this right and very annoying to redo if you do it wrong. One extremely useful LaTeX feature is the ability to define macros for commonly used commands. I strongly encourage you to use macros whenever possible. Not only does this save a considerable amount of typing, but also often an enormous amount of search-replacing. For example, suppose I have a canonical transformation function which I’ll be using throughout the document, but I’m not quite sure how to typeset it yet. So I define the LaTeX macro \\ctran{} and use it. If later I want to redefine how \\ctran{} is typeset that’s an extremely easy fix. Another useful LaTeX trick is to use simple patterns to define macros for common things. For example, I always define bold letter names (which you should use for anything that isn’t a scalar) as \\xx \\YY, etc., and bold symbol names as \\aal for \\(\\boldsymbol{\\alpha}\\), \\TTh for \\(\\boldsymbol{\\Theta}\\), etc. As a rule-of-thumb, avoid defining one-letter macros. The worst LaTeX mistake I’ve ever made is to define \\(\\beta\\) as\\b in everything LaTeX document I wrote before 2015. Now suppose I want to replace \\(\\beta\\) with \\(\\gamma\\) as a symbol for the quantity of interest. Then either I have an extremely confusing macro \\newcommand{\\b}{\\gamma}, or the most annoying search-replace ever (\\begin{xyz} anyone?). Sometimes I do use one letter capital macros, e.g., \\newcommand{\\N}{\\mathcal{N}} for the normal distribution, but these are much easier to search-replace. For this project, LaTeX is rendered to HTML via Mathjax, and thus the macros must be defined a bit differently than in regular LaTeX. All LaTeX macros must be defined in preamble.html. A.2.2 Citations For external websites, it’s sufficient to provide a link as I’ve done in this document. For journal articles, textbooks, conference proceedings, etc. it’s good practice to provide the complete citation information (in addition to a link to the resource if it can be obtained legally for free). For such references please use BibTeX. Add your citations to the bibliography file references.bib. To separate the citations for each module, add the name of your module using the comment sign \\(\\%\\) when you start to add citations. For citation labels, please use the standardized format with the author label followed by the last two digits of the year. The rules for the author labels are, if there is only one author, use @firstauthorlastname, if there are two authors, use @firstauthorlastname.secondauthorlastname, if there are more than 2 authors, use @firstauthorlastname.etal. Here’s some examples (Gelman et al. 2013), (Friedman, Hastie, and Tibshirani 2009). A.3 Rendering the Book For this you will need to install the following packages: install.packages(c(&quot;bookdown&quot;, &quot;tidyverse&quot;, &quot;wooldridge&quot;, &quot;corrplot&quot;, &quot;lmtest&quot;, &quot;caret&quot;, &quot;PMCMRplus&quot;, &quot;dunn.test&quot;, &quot;geesmv&quot;, &quot;emdbook&quot;, &quot;coin&quot;, &quot;randomForest&quot;, &quot;boot&quot;, &quot;e1071&quot;, &quot;inTrees&quot;, &quot;DescTools&quot;, &quot;pwr&quot;, &quot;TOSTER&quot;, &quot;foreach&quot;, &quot;doParallel&quot;, &quot;doSNOW&quot;), dependencies = TRUE) Once this is done, quit + restart R for safe measure. Then, from within the project folder, run bookdown::render_book() To make sure everything is working as expected, you may wish to delete the _book and _bookdown_files folders before rendering. These don’t get cleaned up between runs, so there might be very old files hanging around in there if you don’t periodially perform a manual cleanup. References "],["formatting-guidelines.html", "B Formatting Guidelines B.1 General B.2 Embedding Files B.3 Math", " B Formatting Guidelines Author: Martin Lysy, Trang Bui Last Updated: Feb 04, 2021 B.1 General For a module, name your file starting with mod_ and for a appendix, name your file starting with app_. For headers, place a space between the last sharp symbol \\(\\#\\) and the name of the header. Let’s agree to use regular font for programming languages (e.g., R, Python, C++) and bold font for packages and libraries (e.g., TMB, rstan, NumPy, Tensorflow). Use code font for files, data sets, codes and arguments. For functions, use parentheses at the end, for example, my_func(). Use curly brackets \\bm{} for LaTeX functions. Use &lt;kbd&gt;Key&lt;/kbd&gt; for key strokes or buttons. Paste a link to packages which are mentioned for the first time. For R packages, you can use the cran_link() function to do this. For example, rstan. Please see Appendix B.2.3 for how to handle citations. To refer to figures/tables/sections, use the standard academic style is e.g., “Figure 2”, “Section 2.5”, etc. In other words, the word is non-bold and non-italic, with the first letter capitalized, and the number following the word should have hyperlink. See relevant bookdown chapter for how to do this. To refer to modules, use the text name, details can be found here. Refer to common_functions.R for commonly used functions across modules before writing your own. To make cross-referencing consistent in bookdown, for all labels – code chunks, figures, tables, sections, equations, etc. – use the prefix of the corresponding file as the prefix of any label. So please choose and use a module-specific prefix for each cross-reference. For example, use label #formatguide for this section. Refer to prefixes.txt for the list of the used prefixes and add yours there. Try to use the prefix that is distinctive to other words in the text such that you can find and replace all without mistakes. Give names to all code chunks, even e.g., pure code and figures you don’t refer to. Note: Chunk labels must consist of only letters, numbers, dashes (-), and slashes (/) – no underscores! Otherwise, cross-referencing won’t work properly. Paragraph breaks are simply indicated by one or more empty lines. No need for \\newline or anything else. This applies to elements other than text such as figures, math blocks etc. If the figure/math block/etc is part of the paragraph, don’t leave blank spaces before or after1. Please use Capital Case for all section headings, for example, Plan the Study. Our consensus for writing in a list is mentioned below. For details, visit here. Use - to denote lists. If the items in the list are complete sentences, begin the first word in each item with a capital-case letter and end the item with period. If the items are single words and phrases, begin the first word in each item with a lower-case letter and end with a comma. Use “and” (or “or”, depending on the context of the list) after the next-to-last item, and use a period after the last item in the list. If the items are phrases or clauses with punctuations in them, put a semicolon at the end of each item. Put “and” (or “or”) after the next-to-last item in the list and period for the last item. The items are not capitalized. For indentation, use four spaces before your paragraph, code chunk, or equation. This will be very helpful when you have an item in an itemized list which contains more than one paragraph, equation, or code chunk. Name all code chunks according to the above guideline about cross-references. For code chunks that take long time to run, use cache=TRUE to prevent the chunk to be executed again unless the code in the chunk has been altered. More detail can be found here. Use the package styler to make the formatting of your code consistent. To do this, run the function styler::style_file() for your module’s Rmarkdown file. Do not set the option tidy = \"styler\" to your chunk code to prevent caching issues. The details of the package can be found here. Use “” instead of ’’ for quotes. Use underscore _ instead of dot . to name variables. B.2 Embedding Files To embed a file in your module, first put it in any subdirectory of the data folder of the repo. For example, the repo currently contains the file data/caliRain.csv. You can then use the file anywhere in your module, e.g., head(read.csv(&quot;data/caliRain.csv&quot;)) ## STATION PRECIP ALTITUDE LATITUDE DISTANCE SHADOW ## 1 Eureka 39.57 43 40.8 1 1 ## 2 RedBluff 23.27 341 40.2 97 2 ## 3 Thermal 18.20 4152 33.8 70 2 ## 4 FortBragg 37.48 74 39.4 1 1 ## 5 SodaSprings 49.26 6752 39.3 150 1 ## 6 SanFrancisco 21.82 52 37.8 5 1 In order to let users download the file, you can simply provide the link using regular Markdown syntax. In other words, [download link](data/caliRain.csv) will render as download link. Note: This method works because somewhere in the project we make a call to knitr::include_graphics(\"data/arbitrary/file.ext\"), which has the effect of adding the data folder to the bookdown output directory. In previous attempts we tried explicitly adding the data folder to the output via dir.create(). However, this requires that the output directory be supplied in advance, whereas in general it can be set on-the-fly via the output_dir argument to bookdown::render_book(). B.3 Math Always use bold font like \\(\\XX\\)2 or \\(\\aal\\) for anything that isn’t a scalar. In particular, please use \\bm{} command in math mode to make things bold, and note that bold letters and symbols have standard macros as explained in index.Rmd. Please use them! If applicable distinguish between vectors and matrices (or collections of vectors) with lower and upper case, like \\(\\yy\\) and \\(\\YY\\) or \\(\\tth\\) and \\(\\TTh\\). If the math equations are part of sentences, end them with suitable punctuation. If the formula is a derivation with multiple steps, only put punctuation at the final step. If an equation is to be written in a new line, use two dollar signs to start and finish the equation. For example, consider observations \\(\\XX = (\\rv X N)\\) such that \\[ \\begin{aligned} X_i \\mid \\mu_i &amp; \\ind \\N(\\mu_i, \\sigma_i^2) \\\\ \\mu_i &amp; \\iid \\N(0, \\tau^2). \\end{aligned} \\tag{B.1} \\] Generally, a colon should not be used to set off an equation, even when it is a displayed equation. Typically an equation is the object in a sentence. Use a colon on occasion for emphasis, but make sure it fits grammatically. Examples can be found here. The same rules apply for code chunks. Use \\(j^{th}\\) and \\((i,j)^{th}\\). B.3.1 Commonly-Used Math and Stats Expressions Sequences of random variables: \\(X_1, \\ldots, X_N\\). In fact since these are so common, I’ve created a macro for it: \\(\\rv Y 5\\) and \\(\\rv [m,0] Z {m,N_m}\\). For multi-line equations with alignment, use aligned environment as in (B.1). The “d” in integrals: \\[ \\ud X_t = \\mu(X_t) \\ud t + \\ud B_t \\qquad \\iff \\qquad X_t = \\mu t + \\int_0^t \\mu(X_t) \\ud t + B_t. \\] Conditioning: \\(p(y \\mid x)\\). Independence: \\(Y \\amalg X\\). Probability: \\(\\Pr(Y \\le y)\\). Derivatives and partials: These are quite time-consuming to typeset so I’ve created some macros for them: \\[ \\der{x} f(x), \\qquad \\fdel[3]{x} {g(x, y)}, \\qquad \\hess{\\tth}\\ell(\\tth \\mid \\XX). \\] The last of these is used for Hessian matrices. Independent/IID/Normal: Please see (B.1). Variance/Covariance/Correlation: \\(\\var(X), \\cov(X), \\cor(X)\\). The \\(p\\)-value and the \\(F\\), \\(t\\) or chi-square tests. An exception to this is possibly within an indented region. There you may need to leave a blank space before/after math block…I’m not 100% sure…↩︎ LaTeX purists might prefer to use \\mathbf{} for roman letters instead of \\boldsymbol{} as I have defined via the \\bm{} macro in preamble.html. Observe the difference: \\(\\mathbf{x}\\) vs \\(\\boldsymbol{x}\\) and \\(\\mathbf{X}\\) vs \\(\\boldsymbol{X}\\). For pure LaTeX, the \\bm{} command in the bm package automatically picks the right one for you. Eventually, I’ll figure out how to use this package for the e-book, in which case if you consistently use \\bm{} for bold there will be very little for me to change!↩︎ "],["git-and-github-a-quick-tutorial.html", "C Git and GitHub: A Quick Tutorial C.1 Setup C.2 Contributing to the Project C.3 Git Mistakes", " C Git and GitHub: A Quick Tutorial Author: Martin Lysy Last Updated: Nov 09, 2020 Git is an extremely powerful version control system that is used to “back up” software projects. In a nutshell, rather than overwriting files every time you save them, Git saves the difference between the old and updated versions. This gives you have a complete history of all saves with a minuscule memory overhead, making it very easy to roll back changes, see what you did when, etc. It also has a branching system which is extremely useful to make patches or feature extensions for your software without affecting the “stable” version. Git projects (or “repositories”) can easily be stored on the cloud, which is ideal both for backups and for collaborative work. The most common platform for this is GitHub. You will need a GitHub account in order to access and submit files for this project. It’s completely free, secure, and does not collect or distribute your personal information. You can delete your account at any time, but publicly visible projects can be made to look like a very nice webpage with minimal effort. Therefore, in my opinion, this is a great way to showcase the software you develop for this class or others by providing a link to your GitHub page on your CV. C.1 Setup Install Git and learn some of the basics: https://githowto.com/. Create a free GitHub account: https://github.com/. Send me an email with your GitHub account information so I can add you to this project. C.2 Contributing to the Project The following is the standard Git procedure for collaborating on a project3. Fork the project to your own GitHub account. That is, you’ve now made a complete copy of the project that you can modify however you want without affecting the original. This fork must be kept private (i.e., invisible to the outside world) for the duration of the course. While it is possible to edit the fork directly from GitHub, I strongly recommend against this as it’s extremely inconvenient. Instead, make a local copy of the fork on your computer. In order to make changes to any Git repo, it is always recommended that you create a new branch for this first. That is, assume that the stable version of the repo is on the master branch. Then from the command line, you can do the following: # make sure you are on the master branch git checkout master # create new branch git checkout -b mlysy-devel This will copy everything from master to a new branch called mlysy-devel. Now I can make whatever changes I want to mlysy-devel. Commit your desired changes to the new branch. When you are ready to send them back to the main project repo, follow these steps: Push your local branch to your remote GitHub fork: git push -u origin mlysy-devel Create a GitHub pull request via the button on your fork’s page. When this is done, I will be able to inspect your changes and make suggestions before merging your work into the project-wide stable branch master. C.3 Git Mistakes Git is an extremely versatile program with its own lingo (e.g. push/merge/stash/commit/stage/etc.), all of which takes some time to master. The good news is that it’s easy to “save everything” with Git and very hard to accidentally delete things. To me since the point of using Git is version control, I usually don’t worry about fixing little mistakes (like forgetting to include a file in a commit) that don’t affect this overall goal. There is however one type of Git mistake that’s fairly annoying to fix. This has to do with including large “object” files in the repo. For the purpose of this discussion, object files are files which: Can be completely generated from source code in the repo, e.g., PDF files created with LaTeX, C++ shared object files (.dll, .so, .o), HTML files generated with R Markdown. Cannot be read by a human with a plain text editor, e.g., PDF files, Microsoft Word documents, C++ shared object files, but not HTML files. Get created over and over as the source code in the repo changes. Object files should not be included in Git repos because they take up space and can easily be recreated from source. C++ shared object files are especially useless since they are platform/system-dependent and thus probably won’t work on your collaborator’s computer. Moreover, because object files are not human-readable, Git doesn’t know how to compute the incremental difference between commits, and ends up saving the entire object file every time. This can easily and needlessly bloat the size of the repo. The nuisance here is that if you accidentally commit an object file, simply deleting it won’t remove it from the Git history. Pruning the Git history is a very annoying task, which is why I think of committing object files as the only real Git “mistake”. If you need to prune your Git history, please use this extremely handy repo cleaner. Rather than fixing object file commits after they happen, you can prevent this from happening by using .gitignore file. Simply put, .gitignore files tell Git to ignore certain files in the folder repo. They can contain relative paths and regular expressions. Each .gitignore file applies to the folder and subfolder of where it’s located, so you can have “global” and “local” .gitignore files in the same repo. The global .gitignore for this repo contains a number of common things to ignore in R and C++ projects. Specific to this particular project, it also ignores the _book subfolder which contains the HTML-rendered e-book that you’ll be building to preview on your local machine. If you have been given collaborator rights on a project, you don’t actually need to fork the repo and can simply create branches on the main project from which to issue pull requests. However, forking is the way to go for contributing bugfixes to public repos on your which you are not an official collaborator. Also, it’s very difficult for the project administrator (i.e., me) from preventing other collaborators from interfering with your branch on the main project, but by only you (and the people you authorize) can make changes to the branch on your fork.↩︎ "],["bookdown-tests.html", "D Bookdown Tests D.1 Test Math Macros D.2 Test Figure D.3 Test CRAN Link D.4 Test Checklist D.5 Test References", " D Bookdown Tests A few tests to make sure bookdown is rendering things correctly. D.1 Test Math Macros \\(\\var(\\xx)\\), \\(\\alpha_\\xx\\), \\(\\xx \\ind \\N(0, \\sigma_{\\tx{pool}})\\). D.2 Test Figure plot(1:25, pch = 1:25) Figure D.1: Test figure. The reference to Figure D.1 is implemented correctly. D.3 Test CRAN Link The package link to mniw works correctly. D.4 Test Checklist Can users modify our checklists? Apparently not. Item 1. Item 2. D.5 Test References The reference to Agresti (2015) works as expected. References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
